//  GENERATE.rs
//    by Lut99
// 
//  Created:
//    21 Nov 2022, 15:40:47
//  Last edited:
//    23 Nov 2022, 14:16:49
//  Auto updated?
//    Yes
// 
//  Description:
//!   Handles commands relating to node.yml generation.
// 

use std::fs::File;
use std::io::Write;
use std::path::PathBuf;

use console::style;
use log::{debug, info};

use brane_cfg::node::{Address, CentralConfig, CentralKafkaTopics, CentralPaths, CentralPorts, CentralServices, CommonPaths, CommonPorts, CommonServices, NodeConfig, NodeKindConfig, WorkerConfig, WorkerPaths, WorkerPorts, WorkerServices};

pub use crate::errors::GenerateError as Error;
use crate::spec::GenerateSubcommand;
use crate::utils::resolve_config_path;


/***** HELPER FUNCTIONS ******/
/// Function that writes the standard node.yml header to the given writer.
/// 
/// # Arguments
/// - `writer`: The Writer to write to.
/// 
/// # Returns
/// Nothing, but does update the given writer with the standard header.
/// 
/// # Errors
/// This function errors if we failed to write.
fn write_header(writer: &mut impl Write) -> Result<(), std::io::Error> {
    // Simply call write repeatedly
    writeln!(writer, "# NODE.yml")?;
    writeln!(writer, "#   generated by branectl v{}", env!("CARGO_PKG_VERSION"))?;
    writeln!(writer, "# ")?;
    writeln!(writer, "# This file defines the environment of the local node.")?;
    writeln!(writer, "# Edit this file to change service properties. Some require a restart")?;
    writeln!(writer, "# of the service (typically any 'ports' or 'topics' related setting), but most")?;
    writeln!(writer, "# will be reloaded dynamically by the services themselves.")?;
    writeln!(writer, "# ")?;
    writeln!(writer, "# For an overview of what you can do in this file, refer to")?;
    writeln!(writer, "# https://wiki.enablingpersonalizedinterventions.nl/user-guide/system-admins/docs/config/node.md")?;
    writeln!(writer, "# ")?;
    writeln!(writer)?;
    writeln!(writer)?;

    // And we're done!
    Ok(())
}





/***** LIBRARY *****/
/// Handles generating a new `node.yml` config file for a central _or_ worker node.
/// 
/// # Arguments
/// - `path`: The path to write the central node.yml to.
/// - `proxy`: The address to proxy to, if any (not the address of the proxy service, but rather that of a 'real' proxy).
/// - `config_path`: The path to the config directory that other paths may use as their base.
/// - `common_paths`: Paths that are used by any kind of node.
/// - `common_ports': Ports for services that occur on any kind of node.
/// - `common_services`: Addresses to services that occur on any kind of node.
/// - `command`: The GenerateSubcommand that contains the specific values to write, as well as whether to write a central or worker node.
/// 
/// # Returns
/// Nothing, but does write a new file to the given path and updates the user on stdout on success.
/// 
/// # Errors
/// This function may error if I/O errors occur while writing the file.
pub fn generate(path: impl Into<PathBuf>, proxy: Option<Address>, config_path: impl Into<PathBuf>, common_paths: CommonPaths, common_ports: CommonPorts, common_services: CommonServices, command: GenerateSubcommand) -> Result<(), Error> {
    let path        : PathBuf = path.into();
    let config_path : PathBuf = config_path.into();
    info!("Generating default node.yml for a {}...", match &command { GenerateSubcommand::Central { .. } => { "central node".into() }, GenerateSubcommand::Worker{ location_id, .. } => { format!("worker node with location ID '{}'", location_id) } });

    // Build the NodeConfig
    debug!("Generating node config...");
    let node_config: NodeConfig = match command {
        // Generate the central node
        GenerateSubcommand::Central { infra_path, secrets_path, api_addr, drv_addr, brokers, scylla_svc, api_svc, plr_cmd_topic, plr_res_topic } => {
            NodeConfig {
                proxy,

                paths    : common_paths,
                ports    : common_ports,
                services : common_services,

                node : NodeKindConfig::Central(CentralConfig {
                    paths : CentralPaths {
                        infra    : resolve_config_path(infra_path, &config_path),
                        secrets  : resolve_config_path(secrets_path, &config_path),
                    },
                    ports    : CentralPorts { api: api_addr, drv: drv_addr },
                    services : CentralServices{ brokers, scylla: scylla_svc, api: api_svc },
                    topics   : CentralKafkaTopics{ planner_command: plr_cmd_topic, planner_results: plr_res_topic },
                }),
            }
        },

        // Generate the worker node
        GenerateSubcommand::Worker { location_id, creds_path, data_path, results_path, temp_data_path, temp_results_path, reg_addr, job_addr, reg_svc, chk_svc } => {
            NodeConfig {
                proxy,

                paths    : common_paths,
                ports    : common_ports,
                services : common_services,

                node : NodeKindConfig::Worker(WorkerConfig {
                    location_id,
                    paths : WorkerPaths {
                        creds        : resolve_config_path(creds_path, &config_path),
                        data         : data_path,
                        results      : results_path,
                        temp_data    : temp_data_path,
                        temp_results : temp_results_path,
                    },
                    ports    : WorkerPorts { reg: reg_addr, job: job_addr },
                    services : WorkerServices { reg: reg_svc, chk: chk_svc },
                }),
            }
        },
    };

    // Open the file and write a header to it
    debug!("Writing to '{}'...", path.display());
    let mut handle: File = match File::create(&path) {
        Ok(handle) => handle,
        Err(err)   => { return Err(Error::FileCreateError{ path, err }); },
    };

    // Write the top comment header thingy
    if let Err(err) = write_header(&mut handle) { return Err(Error::FileHeaderWriteError { path, err }); }
    // Write the file itself
    if let Err(err) = node_config.to_writer(handle) { return Err(Error::FileBodyWriteError { path, err }); }

    // Done
    println!("Successfully generated {}", style(path.display().to_string()).bold().green());
    Ok(())
}
