#ifndef brane_cli_h
#define brane_cli_h

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */



template<typename T = void>
struct Arc;

struct Compiler;

/// Defines the error type returned by this library.
struct Error;

/// Defines the error type returned by this library.
struct SourceError;

/// Defines a BRANE instance virtual machine.
///
/// This can run a compiled workflow on a running instance.
struct VirtualMachine;


extern "C" {

/// Compiles the given BraneScript snippet to the BRANE Workflow Representation.
///
/// Note that this function changes the `compiler`'s state.
///
/// # Safety
/// Be aware that the returned [`SourceError`] refers the the given `compiler` and `what`. Freeing any of those two and then using the [`SourceError`] _will_ lead to undefined behaviour.
///
/// You _must_ free this [`SourceError`] using [`serror_free()`], since its allocated using Rust internals and cannot be deallocated directly using `malloc`. Note, however, that it's safe to call [`serror_free()`] _after_ freeing `compiler` or `what` (but that's the only function).
///
/// # Arguments
/// - `compiler`: The [`Compiler`] to compile with. Essentially this determines which previous compile state to use.
/// - `what`: Some string describing what we are compiling (e.g., a file, `<intern>`, a cell, etc.)
/// - `raw`: The raw BraneScript snippet to parse.
/// - `workflow`: Will point to the compiled AST. Will be [`NULL`] if there is an error (see below).
///
/// # Returns
/// A [`SourceError`]-struct describing the error, if any, and source warnings/errors.
///
/// # Panics
/// This function can panic if the given `compiler` points to NULL, or `what`/`raw` does not point to a valid UTF-8 string.
const SourceError *compiler_compile(Compiler *compiler,
                                    const char *what,
                                    const char *raw,
                                    Workflow **workflow);

/// Destructor for the Compiler.
///
/// # Safety
/// You _must_ call this destructor yourself whenever you are done with the struct to cleanup any code. _Don't_ use any C-library free!
///
/// # Arguments
/// - `compiler`: The [`Compiler`] to free.
void compiler_free(Compiler *compiler);

/// Constructor for the Compiler.
///
/// # Arguments
/// - `pindex`: The [`PackageIndex`] to resolve package references in the snippets with.
/// - `dindex`: The [`DataIndex`] to resolve dataset references in the snippets with.
/// - `compiler`: Will point to the newly created [`Compiler`] when done. Will be [`NULL`] if there is an error (see below).
///
/// # Returns
/// [`Null`] in all cases except when an error occurs. Then, an [`Error`]-struct is returned describing the error. Don't forget this has to be freed using [`error_free()`]!
///
/// # Panics
/// This function can panic if the given `pindex` or `dindex` points to NULL.
const Error *compiler_new(const Arc<Mutex<PackageIndex>> *pindex,
                          const Arc<Mutex<DataIndex>> *dindex,
                          Compiler **compiler);

/// Destructor for the DataIndex.
///
/// # Safety
/// You _must_ call this destructor yourself whenever you are done with the struct to cleanup any code. _Don't_ use any C-library free!
///
/// # Arguments
/// - `dindex`: The [`DataIndex`] to free.
void dindex_free(Arc<Mutex<DataIndex>> *dindex);

/// Constructs a new [`DataIndex`] that lists the available datasets in a remote instance.
///
/// # Arguments
/// - `endpoint`: The remote API-endpoint to read the datasets from. The path (`/data/info`) will be deduced and needn't be given, just the host and port.
/// - `dindex`: Will point to the newly created [`DataIndex`] when done. Will be [`NULL`] if there is an error (see below).
///
/// # Returns
/// [`Null`] in all cases except when an error occurs. Then, an [`Error`]-struct is returned describing the error. Don't forget this has to be freed using [`error_free()`]!
///
/// # Panics
/// This function can panic if the given `endpoint` does not point to a valud UTF-8 string.
const Error *dindex_new_remote(const char *endpoint,
                               Arc<Mutex<DataIndex>> **dindex);

/// Destructor for the Error type.
///
/// # Safety
/// You _must_ call this destructor yourself whenever you are done with the struct to cleanup any code. _Don't_ use any C-library free!
///
/// # Arguments
/// - `err`: The [`Error`] to deallocate.
void error_free(Error *err);

/// Prints the error message in this error to stderr.
///
/// # Arguments
/// - `err`: The [`Error`] to print.
///
/// # Panics
/// This function can panic if the given `err` is a NULL-pointer.
void error_print_err(const Error *err);

/// Serializes the error message in this error to the given buffer.
///
/// # Arguments
/// - `err`: the [`Error`] to serialize the error of.
/// - `buffer`: The buffer to serialize to. Will be freshly allocated using `malloc` for the correct size; can be freed using `free()`.
///
/// # Panics
/// This function can panic if the given `err` or `buffer` are NULL-pointers.
void error_serialize_err(const Error *err,
                         char **buffer);

/// Destructor for the FullValue.
///
/// # Safety
/// You _must_ call this destructor yourself whenever you are done with the struct to cleanup any code. _Don't_ use any C-library free!
///
/// # Arguments
/// - `fvalue`: The [`FullValue`] to free.
void fvalue_free(FullValue *fvalue);

/// Checks if this [`FullValue`] needs processing.
///
/// For now, this only occurs when it is a [`FullValue::Data`] (download it) or [`FullValue::IntermediateResult`] (throw a warning).
///
/// # Arguments
/// - `fvalue`: The [`FullValue`] to analyse.
///
/// # Returns
/// True if `vm_process()` should be called on this value or false otherwise.
///
/// # Panics
/// This function can panic if `fvalue` pointed to [`NULL`].
bool fvalue_needs_processing(const FullValue *fvalue);

/// Serializes a FullValue to show as result of the workflow.
///
/// # Arguments
/// - `fvalue`: the [`FullValue`] to serialize.
/// - `data_dir`: The data directory to which we downloaded the `fvalue`, if we did so.
/// - `result`: The buffer to serialize to. Will be freshly allocated using `malloc` for the correct size; can be freed using `free()`.
///
/// # Panics
/// This function can panic if the given `fvalue` is a NULL-pointer or if `data_dir` did not point to a valid UTF-8 string.
void fvalue_serialize(const FullValue *fvalue,
                      const char *data_dir,
                      char **result);

/// Destructor for the PackageIndex.
///
/// # Safety
/// You _must_ call this destructor yourself whenever you are done with the struct to cleanup any code. _Don't_ use any C-library free!
///
/// # Arguments
/// - `pindex`: The [`PackageIndex`] to free.
void pindex_free(Arc<Mutex<PackageIndex>> *pindex);

/// Constructs a new [`PackageIndex`] that lists the available packages in a remote instance.
///
/// # Arguments
/// - `endpoint`: The remote API-endpoint to read the packages from. The path (`/graphql`) will be deduced and needn't be given, just the host and port.
/// - `pindex`: Will point to the newly created [`PackageIndex`] when done. Will be [`NULL`] if there is an error (see below).
///
/// # Returns
/// [`Null`] in all cases except when an error occurs. Then, an [`Error`]-struct is returned describing the error. Don't forget this has to be freed using [`error_free()`]!
///
/// # Panics
/// This function can panic if the given `endpoint` does not point to a valud UTF-8 string.
const Error *pindex_new_remote(const char *endpoint,
                               Arc<Mutex<PackageIndex>> **pindex);

/// Destructor for the Error type.
///
/// # Safety
/// You _must_ call this destructor yourself whenever you are done with the struct to cleanup any code. _Don't_ use any C-library free!
///
/// # Arguments
/// - `serr`: The [`SourceError`] to deallocate.
void serror_free(SourceError *serr);

/// Returns if a program error has occurred.
///
/// # Arguments
/// - `serr`: The [`SourceError`] struct to inspect.
///
/// # Returns
/// True if [`serr_print_err`] would print anything, or false otherwise.
///
/// # Panics
/// This function can panic if the given `err` is a NULL-pointer.
bool serror_has_err(const SourceError *serr);

/// Returns if a source error has occurred.
///
/// # Arguments
/// - `serr`: The [`SourceError`] struct to inspect.
///
/// # Returns
/// True if [`serr_print_serrs`] would print anything, or false otherwise.
///
/// # Panics
/// This function can panic if the given `err` is a NULL-pointer.
bool serror_has_serrs(const SourceError *serr);

/// Returns if a source warning has occurred.
///
/// # Arguments
/// - `serr`: The [`SourceError`] struct to inspect.
///
/// # Returns
/// True if [`serr_print_swarns`] would print anything, or false otherwise.
///
/// # Panics
/// This function can panic if the given `serr` is a NULL-pointer.
bool serror_has_swarns(const SourceError *serr);

/// Prints the error message in this error to stderr.
///
/// Note that there may be no error, but only source warnings- or errors. To discover if there is any, check [`serror_has_err()`].
///
/// # Arguments
/// - `serr`: The [`SourceError`] to print the error of.
///
/// # Panics
/// This function can panic if the given `serr` is a NULL-pointer.
void serror_print_err(const SourceError *serr);

/// Prints the source errors in this error to stderr.
///
/// Note that there may be zero or more errors at once. To discover if there are any, check [`serror_has_serrs()`].
///
/// # Arguments
/// - `serr`: The [`SourceError`] to print the source errors of.
///
/// # Panics
/// This function can panic if the given `serr` is a NULL-pointer.
void serror_print_serrs(const SourceError *serr);

/// Prints the source warnings in this error to stderr.
///
/// Note that there may be zero or more warnings at once. To discover if there are any, check [`serror_has_swarns()`].
///
/// # Arguments
/// - `serr`: The [`SourceError`] to print the source warnings of.
///
/// # Panics
/// This function can panic if the given `serr` is a NULL-pointer.
void serror_print_swarns(const SourceError *serr);

/// Serializes the error message in this error to the given buffer.
///
/// Note that there may be no error, but only source warnings- or errors. To discover if there is any, check [`serror_has_err()`].
///
/// # Arguments
/// - `serr`: the [`SourceError`] to serialize the error of.
/// - `buffer`: The buffer to serialize to.
/// - `max_len`: The length of the buffer. Will simply stop writing if this length is exceeded.
///
/// # Panics
/// This function can panic if the given `serr` or `buffer` are NULL-pointers.
void serror_serialize_err(const SourceError *serr,
                          char **buffer);

/// Serializes the source errors in this error to the given buffer.
///
/// Note that there may be zero or more errors at once. To discover if there are any, check [`serror_has_serrs()`].
///
/// # Arguments
/// - `serr`: the [`SourceError`] to serialize the source errors of.
/// - `buffer`: The buffer to serialize to.
/// - `max_len`: The length of the buffer. Will simply stop writing if this length is exceeded.
///
/// # Panics
/// This function can panic if the given `serr` or `buffer` are NULL-pointers.
void serror_serialize_serrs(const SourceError *serr,
                            char **buffer);

/// Serializes the source warnings in this error to the given buffer.
///
/// Note that there may be zero or more warnings at once. To discover if there are any, check [`serror_has_swarns()`].
///
/// # Arguments
/// - `serr`: the [`SourceError`] to serialize the source warnings of.
/// - `buffer`: The buffer to serialize to. Will be freshly allocated using `malloc` for the correct size; can be freed using `free()`.
///
/// # Panics
/// This function can panic if the given `serr` or `buffer` are NULL-pointers.
void serror_serialize_swarns(const SourceError *serr,
                             char **buffer);

/// Forces the serialization functions to either use colour or not.
///
/// If you don't call this function, then it depends on whether the backend [`console`] library thinks if the stdout/stderr support ANSI colours.
///
/// # Arguments
/// - `force`: If true, then ANSI characters will be forced to be printed. Otherwise, if false, they will be forced to _not_ be printed.
void set_force_colour(bool force);

/// Returns the BRANE version for which this compiler is valid.
///
/// # Returns
/// String version that contains a major, minor and patch version separated by dots.
const char *version();

/// Destructor for the VirtualMachine.
///
/// # Safety
/// You _must_ call this destructor yourself whenever you are done with the struct to cleanup any code. _Don't_ use any C-library free!
///
/// # Arguments
/// - `vm`: The [`VirtualMachine`] to free.
void vm_free(VirtualMachine *vm);

/// Constructor for the VirtualMachine.
///
/// # Arguments
/// - `api_endpoint`: The Brane API endpoint to connect to to download available registries and all that.
/// - `drv_endpoint`: The BRANE driver endpoint to connect to to execute stuff.
/// - `certs_dir`: The directory where certificates for downloading datasets are stored.
/// - `pindex`: The [`PackageIndex`] to resolve package references in the snippets with.
/// - `dindex`: The [`DataIndex`] to resolve dataset references in the snippets with.
/// - `virtual_machine`: Will point to the newly created [`VirtualMachine`] when done. Will be [`NULL`] if there is an error (see below).
///
/// # Returns
/// An [`Error`]-struct that contains the error occurred, or [`NULL`] otherwise.
///
/// # Panics
/// This function can panic if the given `pindex` or `dindex` are NULL, or if the given `api_endpoint`, `drv_endpoint` or `certs_dir` do not point to a valid UTF-8 string.
const Error *vm_new(const char *api_endpoint,
                    const char *drv_endpoint,
                    const char *certs_dir,
                    const Arc<Mutex<PackageIndex>> *pindex,
                    const Arc<Mutex<DataIndex>> *dindex,
                    VirtualMachine **vm);

/// Processes the result referred to by the [`FullValue`].
///
/// Processing currently consists of:
/// - Downloading the dataset if it's a [`FullValue::Data`]
/// - Throwing a warning if it's a [`FullValue::IntermediateResult`]
/// - Doing nothing otherwise
///
/// # Arguments
/// - `vm`: The [`VirtualMachine`] that we download with. This determines which backend to use.
/// - `result`: The [`FullValue`] which we will attempt to download if needed.
/// - `data_dir`: The directory to download the result to. This should be the generic data directory, as a new directory for this dataset will be created within.
///
/// # Returns
/// An [`Error`]-struct that contains the error occurred, or [`NULL`] otherwise.
///
/// # Panics
/// This function may panic if the input `vm` or `result` pointed to a NULL-pointer, or if `data_dir` did not point to a valid UTF-8 string.
const Error *vm_process(VirtualMachine *vm,
                        const FullValue *result,
                        const char *data_dir);

/// Runs the given code snippet on the backend instance.
///
/// # Arguments
/// - `vm`: The [`VirtualMachine`] that we execute with. This determines which backend to use.
/// - `workflow`: The compiled workflow to execute.
/// - `prints`: A newly allocated string which represents any stdout- or stderr prints done during workflow execution. Will be [`NULL`] if there is an error (see below).
/// - `result`: A [`FullValue`] which represents the return value of the workflow. Will be [`NULL`] if there is an error (see below).
///
/// # Returns
/// An [`Error`]-struct that contains the error occurred, or [`NULL`] otherwise.
///
/// # Panics
/// This function may panic if the input `vm` or `workflow` pointed to a NULL-pointer.
const Error *vm_run(VirtualMachine *vm,
                    const Workflow *workflow,
                    char **prints,
                    FullValue **result);

/// Serializes the workflow by essentially disassembling it.
///
/// # Arguments
/// - `workflow`: The [`Workflow`] to disassemble.
/// - `assembly`: The serialized assembly of the same workflow, as a string. Don't forget to free it! Will be [`NULL`] if there is an error (see below).
///
/// # Returns
/// [`Null`] in all cases except when an error occurs. Then, an [`Error`]-struct is returned describing the error. Don't forget this has to be freed using [`error_free()`]!
///
/// # Panics
/// This function can panic if the given `workflow` is a NULL-pointer.
const Error *workflow_disassemble(const Workflow *workflow,
                                  char **assembly);

/// Destructor for the Workflow.
///
/// # Safety
/// You _must_ call this destructor yourself whenever you are done with the struct to cleanup any code. _Don't_ use any C-library free!
///
/// # Arguments
/// - `workflow`: The [`Workflow`] to free.
void workflow_free(Workflow *workflow);

} // extern "C"

#endif // brane_cli_h
